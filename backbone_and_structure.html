<!DOCTYPE html>
<html>
  <head>
    <title>Backbone skal gi meg struktur, men alt er fortsatt bare rot</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.5.min.js" type="text/javascript"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.js" type="text/javascript"></script>
    <link href="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.css" type="text/css" rel="stylesheet">

  </head>
  <body>
    <textarea id="source">

.front-page

# Backbone skal gi meg struktur, men alt er fortsatt bare rot

## Fagdag 1.mars 2013

---

.middle.center
# Hvem er vi og hva skal vi snakke om i dag?

I dag skal vi gå systematisk igjennom ett sett med problemer og misforståelser som er lett å gjøre med Backbone.js


---

# Kort om Backbone

- Ett lite JavaScript rammeverk på omtrent 1500 linjer med kommentarer (6,3kb pakket og gzip'et)
- Blitt svært populært i løpet av de siste årene
- Målet er å gi utviklere stuktur ved hjelp av byggeklossene 
	- Model
	- Collection
	- Views
	- Router

---

.middle.center
# Problemer og misforståelser

---

# Alt skjer overalt #1

Det er viktig å fordele ansvar i en stor JavaScript applikasjon. I Backbone.js er det på helt overordnet nivå delt inn i

- Modeller
- Collections
- Views
- Router

Hver av komponentene har spesifikke ansvarsområder. Ikke endre DOM utenfor viewet, iallefall ikke bruk $ i modeller.

---

# Alt skjer overalt #2

.pushed
![image](backbone_structure.png)

---

# For mye skjer i `initialize` #1

    .javascript
    var UserView = Backbone.View.extend({
      initialize: function() {
        var user = new User();
        var self = this;
        user.fetch({
            success: function() {
                self.render();
            }
        });
      }
    });
   
<!-- 
Notes:

- Vanskelig å mock bort user
- Starter ajaxkallet når man new'er opp objektet, så hver gang noen sier new UserView vil det automagisk gå ett ajax request
- Kaller render fra initialize via callbacket til success

-->

---

# For mye skjer i `initialize` #2

	.javascript
	var UserView = Backbone.View.extend({
		initialize: function(options) {
			this.user = options.user;
			this.listenTo(this.user, 'reset', this.render, this);
		}
	}); 
	
	var user = new User();
	var userView = new UserView({user: user});
	userView.render();
	user.fetch();
	
## Dette er bedre fordi
- 

---

# Jeg vil huske state ved refresh #1
Bruke problemet til kim joar eller min oversikt. Applikasjonen er i en state og man vil at brukeren skal havne der når man trykker refresh. Hva gjør man? Bruker man url, bruker man session storage?

Eksempel med 

Man har en liste og trykker på ett element. Et subview blir renderet. Man trykker refresh. Hvordan skal man komme tilbake til den staten?

---

# Jeg vil huske state ved refresh #2

## Dette er bedre fordi

---

# Bruk av samme DOM element i flere Views #1

    .javascript
    var HeaderView = Backbone.View.extend({
        initialize: function(options) {
          this.user = options.user;
          this.listenTo(this.user, 'change:authLevel', this.authLevelChanged, this);
        },
        authLevelChanged: function(user, authLevel) {
            if (authLevel === 0) {
                this.$el.children.show();
            }
        }
    });

    var LogoutView = Backbone.View.extend({
        initialize: function(options) {
            this.user = options.user;
            this.listenTo(this.user, 'change:authLevel', this.authLevelChanged, this);
        },
        authLevelChanged: function(user, authLevel) {
            if (authLevel === 0) {
                this.$(".logout-button").hide();
            }
        }
    });

    var headerView = new HeaderView({el: $("#header")});
    var logoutView = new LogoutView({el: $("#header")});


<!-- 
Notes:

- Deler ansvarsområdet i stedet for å ha sitt eget
	- Flere utviklere kan da sitte å lage bugs i hverandres views

-->


---

# Bruk av samme DOM element i flere Views #2


## Dette er bedre fordi

- Ansvarfordeling av DOM

---

# For mye logikk i viewene #1

- Her er et eksempel på en model `Transaction` og en collection `Transactions`
- Vi skal lage et view som presenterer en liste med `Transactions`



    .javascript
    var Transaction = Backbone.Model.extend({
        defaults: {
            sum: undefined,
            from: undefined,
            to: undefined,
            createdAt: undefined,
            type: undefined
        }
    });

    var Transactions = Backbone.Collection.extend({
        model: Transaction
    });

---

# For mye logikk i viewene #2
    
    .javascript
    var TransactionsView = Backbone.View.extend({
        events: {
            'click .sortByDate': 'sortByDate'
        },
        initialize: function(options) {
            this.transactions = options.transaction;
        },
        sortByDateAndType: function(e) {
            e.preventDefault();

            var $type = this.$('.transaction-type:selected').val();
            this.transactions.sortBy(function(transaction) {
                var timestamp = Date.parse(transaction.get('createdAt')) * 1000;

                if ($type === 'something') {
                    timestamp += "A";
                } else if ($type === 'somethingElse') {
                    timestamp += "B";
                } else if ($type === 'someOtherThing') {
                    timestamp += "C";
                }

                return timestamp;
            });
        }
    });


---

# For mye logikk i viewene #3


	.javascript
	var TransactionsView = Backbone.View.extend({
    	sortByDateAndType: function(e) {
        	e.preventDefault();
        	var $type = this.$('.transaction-type:selected').val();
        	this.transactions.sortByDateAndType($type);
    	}
	});

	var Transactions = Backbone.Collection.extend({
    	sortByDateAndType: function(type) {
        	this.sortBy(function(transaction) {
            	var timestamp = Date.parse(transaction.get('createdAt')) * 1000;

            	if (type === 'something') {
                	timestamp += "A";
            	} else if (type === 'somethingElse') {
                	timestamp += "B";
            	} else if (type === 'someOtherThing') {
                	timestamp += "C";
            	}

            	return timestamp;
        	});
    	}
	});


---

# Håndtering av templates

Mustache.to_html(..., ...) overalt. Kan legge i BaseView eller noe lignende.

---

# Backbone-plugins er de nye jQuery-plugins

Mange tar over kode som ligger på Backbone, for eksempel Backbone.localStorage som tar over Backbone.sync.

Sjekk kodekvaliteten. Ikke gjør det for avhengig.

magien blir fort ødelagt

tar over, feks sync

don't call me, i'll call you

samle logikk, gjenbruk

---

# Filer ligger overalt

Mappestruktur. Ikke lag egne views, models og collections mapper. Samle moduler
i egen mappe. Dette gjør det faktisk enklere å få rask oversikt over hva app-en
gjør (se på mappenavnene i modules-mappa)

- component
- module
- external

Eller?

- model
- collections
- views
- router
- external

Tilhørlighet

---

# Backbone brukes der det ikke trengs

- I mange tilfeller er det ingen grunn til å bruke Backbone
- Backbone modeller og collections brukes der man trenger å hente data
- Views brukes til å vise dataen
- Alle komponentene rundt trenger ikke vœre knyttet til rammeverket
- Komponenter skal vœre lette, løse små problemer og ha få avhengigheter
- Vi vil gå igjennom noen eksempler på komponenter

---

# Bruker store plugins når det kan løses enkelt i Backbone #1

- I mange tilfeller er det lett å ta inn plugins
- Det kan være godt dokumenterte plugins med masse oppdateringer og followers
- Man bør da tenke, hvilke problem ønsker jeg å løse og løser pluginen akkurat det problemet og ikke det pluss alt annet?
- Store avhengigheter er mer kompleksitet som alle må forstå. Ta for eksempel:
	- [Backbone.Validation](https://github.com/thedersen/backbone.validation)
	- [Backbone-relational.js](http://backbonerelational.org/)
	

---

# Bruker store plugins når det kan løses enkelt i Backbone #2


    .javascript
    var Inbox = Backbone.Model.extend({

      initialize: function() {
        this.messages = new Messages();
      },

      parse: function(resp) {
        this.messages.update(_.clone(resp.messages), { parse: true });
        delete resp.messages;
        return resp;
      },

      toJSON: function() {
        var json = _.clone(this.attributes);
        json.messages = this.messages.toJSON();
        return json;
      }

    });

---

# Ny i kodebasen

- Når man er ny i en kodebase, selv med god kjennskap til rammeverkene, møter man nye måter å bruke rammeverkene på. 
- En huskeregel når man koder kan vœre å ikke overkomplisere enkle problemer, eller løse fremtidige problemer
- Følg rammeverket man har valgt og ikke kjemp mot det
- En annen viktig ting kan vœre å hele tiden tenke på at det kommer en etter deg


	.javascript
	var Transaction = Backbone.Model.extend({});
	
mot
	
	.javascript
	var Transaction = Backbone.Model.extend({
		defaults: {
 			sum: undefined,
            from: undefined,
            to: undefined,
            createdAt: undefined,
            type: undefined
		}	
	});
	

<!--
Ikke gjør for masse magi. Gjør det enkelt og forståelig. Ha en overordnet
"filosofi". Her passer kanskje MVP og sånt.
 -->

---

# Koden min er vanskelig å teste
- Kanskje bedre å blande inn i alle diskusjoner?

---

# Jeg dupliserer ofte kode
- Compoents

---

# View'ene mine blir alt for store #1

- Når man begynner å lage et view så er de ofte små og løser enkle problemer
- Med tiden så kan mange views løse for mange problemer

---


# View'ene mine blir alt for store #2

- For å gjøre det enklere å håndtere store views kan man bruke sub-views
- Sub-views har som hensikt å løse ett enkelt problem for et overordnet view
- De skal kunne flyttes rundt uten konsekvenser
- De skal kunne gjenbrukes på tvers av parent views
- Si man for eksempel har et view som skal vise personalia
	- Personalia kan for eksempel inneholde: Navn, Alder, Addresse


	.javascript	
	var PersonView = Backbone.View.extend({});
	var AddressView = Backbone.View.extend({});
	var PersonalInformationView = Backbone.View.extend({
		initialize: function(options) {
			this.addressView = new AddressView({address: options.address});
			this.personView = new PersonView({person: options.person});
		},
		render: function() {
			this.render();
			this.personView.setElement(this.$('#person'));
			this.personView.render();
			this.addressView.setElement(this.$('#address'));
			this.addressView.render();
			return this;
		}
	});

---

# Oppdatere markup er ett mareritt

- Det kan mange ganger vœre kjipt å endre en header eller lignende som er vanlig å ha på de fleste sider
- For eksempel så vil man bruke h2 i stedet for h1
- Det vil virke litt overkill å lage et subView for en liten header go det vil genere litt mye kode i hvert view man ønsker den også
- Her kan det vœre fint å bruke partials. 
- Partials er deler av templates som kan dyttes inn hvor de trengs. Et eksempel med handlebars.js kan vœre


	.html
	<h1>{{title}}</h1>
	<h2 class="sub-title">{{subTitle}}</h2>

	.html
	{{>header}}
	{{person.firstname}} {{person.lastname}}
	
	.html
	{{>header}}
	{{address.postal}}
	{{address.cordinates}}

---

# Koden min skal dele data #1

- I mange tilfeller så ønsker man å dele data mellom flere objekter i applikasjonen
- Se for deg at man for eksempel har et collection som henter ett sett med regler som styrer hva som er mulig å gjøre i applikasjonen, her er det naturlig å velge å bruke en singleton
- De som ofte skjer med singletons er:
	- Blir for store
	- Vet for mye
	- Brukt for direkte
	- De blir vanskelig å teste
	- Inneholder masse state

---

# Koden min skal dele data #2

- Gjør det slik at en singleton ikke kan new'es opp på noen annen måte
	- Dette gjør at man ikke vil få situasjoner der man ikke vet om man påvirker andre når man endrer den
- Bruk konstruktør injection når man bruker singletons, slik at de blir enkle å mocke bort under testing
- Begrens antall singletons, se etter andre mekanismer, som for eksempel minne-cash, session-storage, local-storage

	
	.javascript
	define([
		'Backbone', 
		'modules/rule/rule'
	], function(
		Backbone,
		Rule
	) {
		var Rules = Backbone.Collection.extend({
			model: Rule
		}); 
	
		return new Rules();
 	});

---

.middle.center

Er det noe vi ikke har nevnt?

    </textarea>
    <div id="slideshow" class="black"></div>
  </body>
</html>

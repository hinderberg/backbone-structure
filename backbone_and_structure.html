<!DOCTYPE html>
<html>
  <head>
    <title>Backbone skal gi meg struktur, men alt er fortsatt bare rot</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.3.5.min.js" type="text/javascript"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.js" type="text/javascript"></script>
    <link href="https://github.com/downloads/kjbekkelund/remark-bekk/bekk-0.0.5.css" type="text/css" rel="stylesheet">

	<style>
	.gap {
	}
	</style>
  </head>
  <body>
    <textarea id="source">

.front-page

# Backbone skal gi meg struktur, men alt er fortsatt bare rot

## Fagdag 1.mars 2013

---

.middle.center
# Hvem er vi og hva skal vi snakke om i dag?

I dag skal vi gå systematisk igjennom ett sett med problemstillinger og misforståelser som er lett å gjøre med Backbone.js

---

# Kort om Backbone

- Ett lite JavaScript rammeverk på omtrent 1500 linjer med kommentarer (6,3kb pakket og gzip'et)
- Blitt svært populært i løpet av de siste årene
- Målet er å gi utviklere stuktur ved hjelp av et sett med byggeklosser

---

.middle.center
# Et sett med problemstillinger og misforståelser

---

# Hvem har ansvar for hva? #1

- Det er en kjent sak at det fort blir mye som skjer overalt i en stor JavaScript applikasjon
- Det blir vanskelig å få oversikt og det er lett å innføre `bugs`



- Det er her Backbone kan vœre til stor hjelp og følgende byggeklosser er laget for å hjelpe til:
	- Modeller
	- Collections
	- Views
	- Router
	
- Hver komponent spesifikke ansvarsområder

---

# Hvem har ansvar for hva? #2

.pushed
![image](backbone_structure.png)


---

# For mye skjer i `initialize` #1


    .javascript
    var UserView = Backbone.View.extend({
      initialize: function() {
        var user = new User();
        var self = this;
        user.fetch({
            success: function() {
                self.render();
            }
        });
      }
    });
   
<!-- 
Notes:

- Vanskelig å mock bort user
- Starter ajaxkallet når man new'er opp objektet, så hver gang noen sier new UserView vil det automagisk gå ett ajax request
- Kaller render fra initialize via callbacket til success

-->

---

# For mye skjer i `initialize` #2

- Viewet skal helst ikke hente sin egen data, det skal få data
- Viewet skal respondere på data endringer


	.javascript
	var UserView = Backbone.View.extend({
		initialize: function(options) {
			this.user = options.user;
			this.listenTo(this.user, 'reset', this.render, this);
		}
	}); 
	
	var user = new User();
	var userView = new UserView({user: user});
	userView.render();
	user.fetch();

---

# Bruk av samme DOM element i flere Views #1

    .javascript
    var HeaderView = Backbone.View.extend({
        initialize: function(options) {
          this.user = options.user;
          this.listenTo(this.user, 'change:authLevel', this.authLevelChanged, this);
        },
        authLevelChanged: function(user, authLevel) {
            if (authLevel === 0) {
                this.$el.children.show();
            }
        }
    });

    var LogoutView = Backbone.View.extend({
        initialize: function(options) {
            this.user = options.user;
            this.listenTo(this.user, 'change:authLevel', this.authLevelChanged, this);
        },
        authLevelChanged: function(user, authLevel) {
            if (authLevel === 0) {
                this.$(".logout-button").hide();
            }
        }
    });

    var headerView = new HeaderView({el: $("#header")});
    var logoutView = new LogoutView({el: $("#header")});


<!-- 
Notes:

- Deler ansvarsområdet i stedet for å ha sitt eget
	- Flere utviklere kan da sitte å lage bugs i hverandres views

-->


---

# Bruk av samme DOM element i flere Views #2

- Ansvarfordeling av DOM

---

# For mye logikk i viewene #1

- Her er et eksempel på en model `Transaction` og en collection `Transactions`
- Vi skal lage et view som presenterer en liste med `Transactions`



    .javascript
    var Transaction = Backbone.Model.extend({
        defaults: {
            sum: undefined,
            from: undefined,
            to: undefined,
            createdAt: undefined,
            type: undefined
        }
    });

    var Transactions = Backbone.Collection.extend({
        model: Transaction
    });

---

# For mye logikk i viewene #2
    
    .javascript
    var TransactionsView = Backbone.View.extend({
        events: {
            'click .sortByDate': 'sortByDate'
        },
        initialize: function(options) {
            this.transactions = options.transaction;
        },
        sortByDateAndType: function(e) {
            e.preventDefault();

            var $type = this.$('.transaction-type:selected').val();
            this.transactions.sortBy(function(transaction) {
                var timestamp = Date.parse(transaction.get('createdAt')) * 1000;

                if ($type === 'something') {
                    timestamp += "A";
                } else if ($type === 'somethingElse') {
                    timestamp += "B";
                } else if ($type === 'someOtherThing') {
                    timestamp += "C";
                }

                return timestamp;
            });
        }
    });


---

# For mye logikk i viewene #3


	.javascript
	var TransactionsView = Backbone.View.extend({
    	sortByDateAndType: function(e) {
        	e.preventDefault();
        	var $type = this.$('.transaction-type:selected').val();
        	this.transactions.sortByDateAndType($type);
    	}
	});

	var Transactions = Backbone.Collection.extend({
    	sortByDateAndType: function(type) {
        	this.sortBy(function(transaction) {
            	var timestamp = Date.parse(transaction.get('createdAt')) * 1000;

            	if (type === 'something') {
                	timestamp += "A";
            	} else if (type === 'somethingElse') {
                	timestamp += "B";
            	} else if (type === 'someOtherThing') {
                	timestamp += "C";
            	}

            	return timestamp;
        	});
    	}
	});



---

# View'ene mine blir alt for store #1

- Når man begynner å lage et view så er de ofte små og løser enkle problemer
- Med tiden så kan hvert enkelt view løse for mange problemer
- De blir store og klumpete
- Vanskelig å få oversikt
- Vanskelig å teste

---


# View'ene mine blir alt for store #2

- For å gjøre det enklere å håndtere store views kan man bruke sub-views
- Sub-views har som hensikt å løse ett enkelt problem for et overordnet view
- De skal kunne flyttes rundt uten konsekvenser
- De skal kunne gjenbrukes på tvers av parent views
- Si man for eksempel har et view som skal vise personalia
	- Personalia kan for eksempel inneholde: Navn, Alder, Addresse


	.javascript	
	var PersonView = Backbone.View.extend({});
	var AddressView = Backbone.View.extend({});
	var PersonalInformationView = Backbone.View.extend({
		initialize: function(options) {
			this.addressView = new AddressView({address: options.address});
			this.personView = new PersonView({person: options.person});
		},
		render: function() {
			this.render();
			this.personView.setElement(this.$('#person'));
			this.personView.render();
			this.addressView.setElement(this.$('#address'));
			this.addressView.render();
			return this;
		}
	});

---

# Oppdatere markup er ett mareritt

- Det kan mange ganger vœre kjipt å endre en header eller lignende som er vanlig å ha på de fleste sider
- For eksempel så vil man bruke h2 i stedet for h1
- Det vil virke litt overkill å lage et subView for en liten header go det vil genere litt mye kode i hvert view man ønsker den også
- Her kan det vœre fint å bruke partials. 
- Partials er deler av templates som kan dyttes inn hvor de trengs. Et eksempel med handlebars.js kan vœre


	.html
	<h1>{{title}}</h1>
	<h2 class="sub-title">{{subTitle}}</h2>

	.html
	{{>header}}
	{{person.firstname}} {{person.lastname}}
	
	.html
	{{>header}}
	{{address.postal}}
	{{address.cordinates}}

---

# Håndtering av templates

Mustache.to_html(..., ...) overalt. Kan legge i BaseView eller noe lignende.

---

# Koden min skal dele data #1

- I mange tilfeller så ønsker man å dele data mellom flere objekter i applikasjonen
- Se for deg at man for eksempel har et collection som henter ett sett med regler som styrer hva som er mulig å gjøre i applikasjonen, her er det naturlig å velge å bruke en singleton
- De som ofte skjer med singletons er:
	- Blir for store
	- Vet for mye
	- Brukt for direkte
	- De blir vanskelig å teste
	- Inneholder masse state

---

# Koden min skal dele data #2

- Gjør det slik at en singleton ikke kan new'es opp på noen annen måte
	- Dette gjør at man ikke vil få situasjoner der man ikke vet om man påvirker andre når man endrer den
- Bruk konstruktør injection når man bruker singletons, slik at de blir enkle å mocke bort under testing
- Begrens antall singletons, se etter andre mekanismer, som for eksempel minne-cash, session-storage, local-storage

	
	.javascript
	define([
		'Backbone', 
		'modules/rule/rule'
	], function(
		Backbone,
		Rule
	) {
		var Rules = Backbone.Collection.extend({
			model: Rule
		}); 
	
		return new Rules();
 	});

---

# Backbone-plugins er de nye jQuery-plugins #1

- Plugins skal i teorien vœre komponenter som løser et problem som et rammeverk ikke ønsker å ta stilling til
- Problemet med mange plugins er at de tar over kode som ligger på Backbone
	- Eksemplet på dette er Backbone.localStorage som tar over Backbone.sync.

## Tips

- Sjekk kodekvaliteten på pluginen du ønsker å dra inn
- Ikke gjør applikasjonen din for avhengig, utvikling på pluginen kan plutselig slutte
- Plugins kan vœre kult og gjøre mye magi, men husk at magien blir fort ødelagt om man ønsker å gjøre små endringer
- Prøve å finn plugins som følger prinsippet: "don't call me, i'll call you"

---


# Backbone brukes der det ikke trengs

- Komponenter som vi har valgt å kalle dem er et forsøk på å bidra til å gjøre plugins mer håndterbare
- De skal vœre små
- Løse enkle problemer
- Hindre duplisering av kode

- I mange tilfeller er det ingen grunn til å bruke Backbone
- Backbone modeller og collections brukes der man trenger å hente data
- Views brukes til å vise dataen
- Alle komponentene rundt trenger ikke vœre knyttet til rammeverket
- Komponenter skal vœre lette, løse små problemer og ha få avhengigheter
- Vi vil gå igjennom noen eksempler på komponenter

---

# Bruker store plugins når det kan løses enkelt i Backbone #1

- I mange tilfeller er det lett å ta inn plugins
- Det kan være godt dokumenterte plugins med masse oppdateringer og followers
- Man bør da tenke, hvilke problem ønsker jeg å løse og løser pluginen akkurat det problemet og ikke det pluss alt annet?
- Store avhengigheter er mer kompleksitet som alle må forstå. Ta for eksempel:
	- [Backbone.Validation](https://github.com/thedersen/backbone.validation)
	- [Backbone-relational.js](http://backbonerelational.org/)
	

---

# Bruker store plugins når det kan løses enkelt i Backbone #2


    .javascript
    var Inbox = Backbone.Model.extend({

      initialize: function() {
        this.messages = new Messages();
      },

      parse: function(resp) {
        this.messages.update(_.clone(resp.messages), { parse: true });
        delete resp.messages;
        return resp;
      },

      toJSON: function() {
        var json = _.clone(this.attributes);
        json.messages = this.messages.toJSON();
        return json;
      }

    });

---


# Filer ligger overalt

- Kan virke banalt å tenke på, men er utrolig viktig
- 

Mappestruktur. Ikke lag egne views, models og collections mapper. Samle moduler
i egen mappe. Dette gjør det faktisk enklere å få rask oversikt over hva app-en
gjør (se på mappenavnene i modules-mappa)

- component
- module
- external

Eller?

- model
- collections
- views
- router
- external

Tilhørlighet

---


# Ny i kodebasen

- Når man er ny i en kodebase, selv med god kjennskap til rammeverkene, møter man nye måter å bruke rammeverkene på. 
- En huskeregel når man koder kan vœre å ikke overkomplisere enkle problemer, eller løse fremtidige problemer
- Følg rammeverket man har valgt og ikke kjemp mot det
- En annen viktig ting kan vœre å hele tiden tenke på at det kommer en etter deg


	.javascript
	var Transaction = Backbone.Model.extend({});
	
mot
	
	.javascript
	var Transaction = Backbone.Model.extend({
		defaults: {
 			sum: undefined,
            from: undefined,
            to: undefined,
            createdAt: undefined,
            type: undefined
		}	
	});
	

<!--
Ikke gjør for masse magi. Gjør det enkelt og forståelig. Ha en overordnet
"filosofi". Her passer kanskje MVP og sånt.
 -->

---


# Jeg vil huske state ved refresh #1
Bruke problemet til kim joar eller min oversikt. Applikasjonen er i en state og man vil at brukeren skal havne der når man trykker refresh. Hva gjør man? Bruker man url, bruker man session storage?

Eksempel med 

Man har en liste og trykker på ett element. Et subview blir renderet. Man trykker refresh. Hvordan skal man komme tilbake til den staten?

---

# Jeg vil huske state ved refresh #2

## Huskeliste

---

# Koden min er vanskelig å teste
- Kanskje bedre å blande inn i alle diskusjoner?

---


# Huskelisten

- Ikke endre DOM utenfor views, iallefall ikke bruk jQuery i modeller og andre databærere

---


.middle.center

Spørsmål? <br/>
Tid til en liten diskusjon?

    </textarea>
    <div id="slideshow" class="black"></div>
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <title>Backbone skal gi meg struktur, men alt er fortsatt bare rot</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="remark-0.4.4.min.js" type="text/javascript"></script>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,300italic,400|Dosis:300,400|Source+Code+Pro:200,300,400,400bold' rel='stylesheet' type='text/css'>

    <style type="text/css" media="screen">
        h1, h2, h3 { font-family: 'Dosis', sans-serif; }
        h1 { font-weight: 300; font-size: 50px; }
        p, li { font-family: 'Source Sans Pro', sans-serif; font-weight: 300; }
        code { font-family: 'Source Code Pro', sans-serif !important; }
        pre code { background-color: #fff; border-top: 5px solid #ddd; border-bottom: 5px solid #ddd; }
        h1 code { font-weight: 300; font-size: 1em !important; background-color: #eee; padding: 0px 5px; border-radius: 5px; }
        img { max-width: 100%; }
        blockquote { font-style: italic; font-weight: 300; }

        .red       { background-color: #E8664E; color: #fff; }
        .green     { background-color: #79A700; color: #fff; }
        .blue      { background-color: #449BB5; color: #fff; }
        .dark-blue { background-color: #043D5D; color: #fff; }
        .yellow    { background-color: #F5E653; color: #fff; }
        .black     { background-color: #000000; color: #fff; }

        .position { display: none; }

        .codercat img {
          position: absolute;
          top: -50px;
          left: 0;
          margin-left: 20%;
        }
        .codercat .me {
          position: absolute;
          top: 155px;
          width: 300px;
          text-align: center;
          left: 40px;
          font-size: 50px;
          font-family: 'Dosis', sans-serif;
        }

        #slideshow .slide .html5 {
          padding: 0;
        }
        .html5 img {
          width: 70%;
        }

        .mega { background-color: #1D6D8E; color: #fff; }
        .mega h1 { font-size: 6em; }

        .cols {}
        .col1-3 { width: 33.3333%; float: left; }

        .ie10 img {
          position: absolute;
          top: 15%;
          left: 16%;
          width: 17%;
        }
        .ie10-desc {
          position: absolute;
          top: 36%;
          left: 25%;
        }
        .chrome img {
          position: absolute;
          top: 60%;
          left: 16%;
          width: 17%;
        }

  </style>
  </head>
  <body>
    <textarea id="source">

class: middle, center

# Backbone skal gi meg struktur, 
## men alt er fortsatt bare rot

### Fagdag 1.mars 2013

---

class: middle, center

# Hvem er vi?

Kim Joar Bekkelund

Hans Magnus Inderberg

---

class: middle, center

# Hva skal vi snakke om i dag?

Problemstillinger og misforståelser som er lett å gjøre med Backbone.js

---

# Kort om Backbone

Lite JavaScript rammeverk på omtrent 1000 linjer (6,3kb pakket og gzip-et)

Blitt svært populært i løpet av de siste årene

Målet er å gi utviklere stuktur ved hjelp av et sett med byggeklosser

> Greier ikke helt å komme i land med målet, hvorfor ellers skulle vi snakket i dag?
  
&nbsp;

**Blitt er rammeverk som er mye brukt på prosjekter i BEKK**

---

class: middle, center

# Et sett med problemstillinger og misforståelser

---

class: middle, center

# Hvem har ansvar for hva?

---

# Hvem har ansvar for hva?

Kan fort bli mye som skjer overalt i en stor JavaScript-applikasjon

Det blir vanskelig å få oversikt og det er lett å innføre "bugs"

Backbone har et sett med byggeklosser som skal hjelpe til:

- Modeller
- Collections
- Views
- Router

&nbsp;

** Hver byggekloss har sine spesifikke ansvarsområder **

---

# Model

Databærer som arver fra `Backbone.Model`

Kommuniserer med server ved hjelp av for eksempel ajax

Logikk for å behandle og validere data

** Ingen forståelse eller kjenskap om DOM **

&nbsp;

```javascript
var Transaction = Backbone.Model.extend({
  defaults: {
    from: undefined,
    to: undefined,
    sum: undefined
  }
});

var transaction = new Transaction({
  from: "Gunnar"
  to: "Jens"
  sum: "1500.00"
});

```

---

# Collection

Enkel komponent som har til hensik å holde på en samling av modeller

Inneholder blant annet logikk for å sortere og få et gitt utdrag av modeller

** Ingen forståelse eller kjenskap om DOM **

&nbsp;

```javascript
var Transactions = Backbone.Collection.extend({
    model: Transaction
});

var transactions = new Transactions([transaction1, transaction2]);
```

---

# View

Deles inn i logiske deler som brukeren skal få presentert

Skal ** ikke ** inneholde business logikk

Inneholder logikk for animasjoner og annen jQuery magi

Har ikke lov å gå utover sin egen DOM element

Kontrollerer alt innenfor sitt DOM element

```javascript
var TransactionsView = Backbone.View.extend({
  events: { ... },
  initialize: function() { ... },
  render: function() { ... }
});

var transactionsView = new TransactionView({ transactions: transactions });
```

## template

Viewene har ansvar for å bygge templates og legge del inn i sitt eget DOM element `$el`

---

# Router

Bestemmer staten til applikasjonen

Bytter ut views ved navigering

Lytter på URL endringer

Sender modeller og collections inn til view'ene

Sørger for å starte hentingen av data'en view'et er avhengig av

```javascript
var Router = Backbone.Router.extend({
  routes: {
    'transactions': 'transactions' 
  },
  transactions: function() {
      var transactions = new Transactions();
      var transactionsView = new TransactionView({ 
        transactions: transactions 
      });
      transactions.fetch();
  }
});
```

---

# Events

Events er en måte å de-koble kommunikasjon mellom JavaScript objekter

`Backbone.Events` er en komponent som kan mikses inn i hvilke som helst objekt

Gir komponenten egenskpen å `binde` til events og `trigge` events

Alle komponentene i Backbone bruker events

Store deler av kommunikasjonen i applikasjonen gjøres ved hjelp av events

```javascript
this.model.on(eventNavn, callback, context);


var doSomething = function() {
  
};

this.transactions.on("reset", doSomething, this);
```

---

# Hvem har ansvar for hva?

Kommunikasjon

![](backbone_structure.png)

---

class: middle, center

# For mye skjer i `initialize`

---

# For mye skjer i `initialize`

```javascript
var UserView = Backbone.View.extend({

    initialize: function() {

        // lager en modell
        var user = new User();

        var self = this;

        // henter data
        user.fetch({

            success: function() {
                // rendrer view når data er mottatt
                self.render();
            }

        });

    }

});
```

<!-- 
Notes:

- Vanskelig å mock bort user
- Starter ajaxkallet når man new'er opp objektet, så hver gang noen sier new UserView vil det automagisk gå ett ajax request
- Kaller render fra initialize via callbacket til success

-->

---

# For mye skjer i `initialize`

Viewet skal helst ikke hente sin egen data, det skal få data

Viewet skal respondere på data-endringer

```javascript
var UserView = Backbone.View.extend({

    initialize: function(options) {
        this.user = options.user;
        this.user.on('change', this.render, this);
    }

});

var user = new User();
var userView = new UserView({ user: user });
user.fetch();
```

---

class: middle, center

# For mye logikk i viewene

---

# For mye logikk i viewene

Her er et eksempel på en model `Transaction` og en collection `Transactions`

Vi skal lage et view som presenterer en liste med `Transactions`

```javascript
var Transaction = Backbone.Model.extend({
    defaults: {
        sum: undefined,
        from: undefined,
        to: undefined,
        createdAt: undefined
    }
});

var Transactions = Backbone.Collection.extend({
    model: Transaction
});
```

---

# For mye logikk i viewene

```javascript
var TransactionsView = Backbone.View.extend({
    events: {
        'click .sortByDate': 'sortByDateAndType'
    },
    initialize: function(options) {
        this.transactions = options.transaction;
    },
    sortByDateAndType: function(e) {
        e.preventDefault();

        var type = this.$('.transaction-type:selected').val();
        this.transactions.sortBy(function(transaction) {
            var timestamp = Date.parse(transaction.get('createdAt')) * 1000;
            if (type === 'something') {
                timestamp += "A";
            } else if (type === 'somethingElse') {
                timestamp += "B";
            } else if (type === 'someOtherThing') {
                timestamp += "C";
            }
            return timestamp;
        });
    }
});
```

---

# For mye logikk i viewene

Flytt logikk til `model` og `collection`:

```javascript
var TransactionsView = Backbone.View.extend({

    events: {
        'click .sortByDate': 'sortByDateAndType'
    },

    initialize: function(options) {
        this.transactions = options.transaction;
    },

    sortByDateAndType: function(e) {
        e.preventDefault();

        var type = this.$('.transaction-type:selected').val();
        this.transactions.sortByDateAndType(type);
    }

});
```

---

class: middle, center

Kim tar over

# View'ene mine blir alt for store

---

class: middle, center

![](images/store-views.png)

---

class: middle, center

![](images/store-views2.png)

---

class: middle, center

Bildet med markering på hvor viewene er

---

# View'ene mine blir alt for store

Starter alltid små

… men de vokser og vokser

… og blir mer og mer komplekse

… og det blir vanskelig å få oversikt

… og det blir vanskelig å teste dem

---

# View'ene mine blir alt for store

Løsningen? Del viewet inn i **subviews**!

De skal kunne flyttes rundt uten konsekvenser

De skal kunne gjenbrukes på tvers av parent views

---

# View'ene mine blir alt for store

```javascript
var PersonView = Backbone.View.extend({});

var AddressView = Backbone.View.extend({});

var PersonalInformationView = Backbone.View.extend({

    initialize: function(options) {
        this.addressView = new AddressView({ address: options.address });
        this.personView = new PersonView({ person: options.person });
    },

    render: function() {
        this.renderTemplate();

        this.personView.setElement(this.$('#person'));
        this.personView.render();

        this.addressView.setElement(this.$('#address'));
        this.addressView.render();

        return this;
    }
});
```

---

class: middle, center

# Arv

---

# Arv

`BaseView` osv

`Mustache.to_html(..., ...)` overalt. Kan legge i BaseView eller noe lignende.

---

# Oppdatere markup er ett mareritt

kjipt å endre en header som er vanlig å ha på de fleste sider

For eksempel så vil man bruke `h2` i stedet for `h1`

Kan være overkill å lage et subview for en liten header

---

# Oppdatere markup er ett mareritt

Mulig løsning: Partials!

Partials er deler av templates som kan dyttes inn hvor de trengs.

```html
<h1>{{title}}</h1>
<h2 class="sub-title">{{subTitle}}</h2>
```

```html
{{>header}}

<p>{{person.firstname}} {{person.lastname}}</p>
```

```html
{{>header}}

<p>{{address.postal}}</p>
<p>{{address.cordinates}}<p>
```

---

class: middle, center

# Koden min skal dele data

# Mulig nytt fokus: Det er viktig at det bare finnes én

---

# Koden min skal dele data

!! DENNE ER VANSKELIG Å FORSTÅ

- Hva er en singleton?

I mange tilfeller så ønsker man å dele data mellom flere objekter i applikasjonen

Se for deg at man for eksempel har et collection som henter ett sett med regler som styrer hva som er mulig å gjøre i applikasjonen, her er det naturlig å velge å bruke en singleton

---

# Koden min skal dele data

Gjør det slik at en singleton ikke kan new'es opp på noen annen måte

- Dette gjør at man ikke vil få situasjoner der man ikke vet om man påvirker andre når man endrer den

Bruk konstruktør injection når man bruker singletons, slik at de blir enkle å mocke bort under testing

Begrens antall singletons, se etter andre mekanismer, som for eksempel minne-cash, session-storage, local-storage

```javascript
define(['Backbone', 'modules/rule/rule'], function(Backbone, Rule) {
    var Rules = Backbone.Collection.extend({
        model: Rule
    });

    return new Rules();
});
```

Singletons kan være positivt, men det er noen problemer:

- Blir for store
- Vet for mye
- Brukt for direkte
- De blir vanskelig å teste
- Inneholder masse state

---

class: middle, center

# Backbone-plugins = jQuery-plugins

---

# Backbone-plugins = jQuery-plugins

Shitty kvalitet på det meste

Plugins skal i teorien vœre komponenter som løser et problem som et rammeverk ikke ønsker å ta stilling til

Mange plugins tar over kode som ligger på `Backbone`

Eksempel fra `Backbone.localStorage`:

```javascript
// Override 'Backbone.sync' to default to localSync,
// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'

Backbone.sync = function(method, model, options) {
    return Backbone.getSyncMethod(model).apply(this, [method, model, options]);
};
```

---

# Backbone-plugins = jQuery-plugins

## Tips

- Sjekk kodekvaliteten på pluginen du ønsker å dra inn
- Ikke gjør applikasjonen din for avhengig, utvikling på pluginen kan plutselig slutte
- Plugins kan vœre kult og gjøre mye magi, men husk at magien blir fort ødelagt om man ønsker å gjøre små endringer

Følg Hollywood-prinsippet:

> Don't call me, I'll call you

---

# Trenger du egentlig denne plugin-en?

Lett å dra inn — potensielt masse kompleksitet

Det kan være godt dokumenterte plugins med masse oppdateringer og followers

Man bør da tenke, hvilke problem ønsker jeg å løse og løser pluginen akkurat det problemet og ikke det pluss alt annet?

Store avhengigheter er mer kompleksitet som alle må forstå.

For eksempel:

- [Backbone-relational.js](http://backbonerelational.org/) er større enn Backbone selv

---

# Trenger du egentlig denne plugin-en?

Enkelt å la en modell inneholde en collection:

    .javascript
    var Inbox = Backbone.Model.extend({

      initialize: function() {
        this.messages = new Messages();
      },

      parse: function(resp) {
        this.messages.update(_.clone(resp.messages), { parse: true });
        delete resp.messages;
        return resp;
      },

      toJSON: function() {
        var json = _.clone(this.attributes);
        json.messages = this.messages.toJSON();
        return json;
      }

    });


---

class: middle, center

# Backbone brukes der det ikke trengs

---

# Backbone brukes der det ikke trengs

!! Komponenter

Komponenter som vi har valgt å kalle dem er et forsøk på å bidra til å gjøre plugins mer håndterbare

De skal vœre små

Løse enkle problemer

Hindre duplisering av kode

Backbone modeller og collections brukes der man trenger å hente data

Views brukes til å vise dataen

Alle komponentene rundt trenger ikke vœre knyttet til rammeverket

Komponenter skal vœre lette, løse små problemer og ha få avhengigheter

Vi vil gå igjennom noen eksempler på komponenter

---

class: middle, center

# Filer ligger overalt

---

# Filer ligger overalt

Kan virke banalt, men det er utrolig viktig

Mappestruktur. Ikke lag egne views, models og collections mapper. Samle moduler
i egen mappe. Dette gjør det faktisk enklere å få rask oversikt over hva app-en
gjør (se på mappenavnene i modules-mappa)

- component
- module
- external

Eller?

- model
- collections
- views
- router
- external

Tilhørlighet

---

# Filer ligger overalt

```sh
$ tree
.
├── app.js
├── components
│   ├── subViewHandler.js
│   └── validation.js
├── index.html
├── libs
│   ├── backbone-0.9.10.js
│   ├── jquery-1.9.1.js
│   └── underscore-1.4.4.js
└── modules
    └── payments
        ├── payment.js
        ├── payment.mustache
        ├── paymentView.js
        └── payments.js

4 directories, 11 files
```

---

# Filer ligger overalt

Require.js-eksempel. Trenger ikke lengre "full path".

---

class: middle, center

# Huskeliste

---

# Huskeliste

Testbarhet ≈ struktur

Ny i kodebasen

Når man er ny i en kodebase, selv med god kjennskap til rammeverkene, møter man nye måter å bruke rammeverkene på

Følg rammeverket man har valgt og ikke kjemp mot det

En annen viktig ting kan vœre å hele tiden tenke på at det kommer en etter deg

```javascript
var Transaction = Backbone.Model.extend({});
```

vs

```javascript
var Transaction = Backbone.Model.extend({
    defaults: {
        sum: undefined,
        from: undefined,
        to: undefined,
        createdAt: undefined,
        type: undefined
    }
});

Ikke gjør for masse magi

Gjør det enkelt og forståelig

Ha en overordnet "filosofi"

---

class: middle, center, black

# Spørsmål?

# Uenig?

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <title>Backbone skal gi meg struktur, men alt er fortsatt bare rot</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="remark-0.4.4.min.js" type="text/javascript"></script>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,300italic,400|Dosis:300,400|Source+Code+Pro:200,300,400,400bold' rel='stylesheet' type='text/css'>

    <style type="text/css" media="screen">
        h1, h2, h3 { font-family: 'Dosis', sans-serif; }
        h1 { font-weight: 300; font-size: 50px; }
        p, li { font-family: 'Source Sans Pro', sans-serif; font-weight: 300; }
        code { font-family: 'Source Code Pro', sans-serif !important; }
        pre code { background-color: #fff; border-top: 5px solid #ddd; border-bottom: 5px solid #ddd; }
        h1 code { font-weight: 300; font-size: 1em !important; background-color: #eee; padding: 0px 5px; border-radius: 5px; }
        img { max-width: 100%; }
        blockquote { font-style: italic; font-weight: 300; }

        .red       { background-color: #E8664E; color: #fff; }
        .green     { background-color: #79A700; color: #fff; }
        .blue      { background-color: #449BB5; color: #fff; }
        .dark-blue { background-color: #043D5D; color: #fff; }
        .yellow    { background-color: #F5E653; color: #fff; }
        .black     { background-color: #000000; color: #fff; }

        .position { display: none; }

        .codercat img {
          position: absolute;
          top: -50px;
          left: 0;
          margin-left: 20%;
        }
        .codercat .me {
          position: absolute;
          top: 155px;
          width: 300px;
          text-align: center;
          left: 40px;
          font-size: 50px;
          font-family: 'Dosis', sans-serif;
        }

        #slideshow .slide .html5 {
          padding: 0;
        }
        .html5 img {
          width: 70%;
        }

        .mega { background-color: #1D6D8E; color: #fff; }
        .mega h1 { font-size: 6em; }

        .cols {}
        .col1-3 { width: 33.3333%; float: left; }

        .ie10 img {
          position: absolute;
          top: 15%;
          left: 16%;
          width: 17%;
        }
        .ie10-desc {
          position: absolute;
          top: 36%;
          left: 25%;
        }
        .chrome img {
          position: absolute;
          top: 60%;
          left: 16%;
          width: 17%;
        }

	</style>
  </head>
  <body>
    <textarea id="source">

# Backbone skal gi meg struktur, men alt er fortsatt bare rot

## Fagdag 1.mars 2013

---

class: middle, center

# Hvem er vi og hva skal vi snakke om i dag?

I dag skal vi gå systematisk igjennom ett sett med problemstillinger og misforståelser som er lett å gjøre med Backbone.js

---

# Kort om Backbone

Lite JavaScript rammeverk på omtrent 1000 linjer (6,3kb pakket og gzip-et)

Blitt svært populært i løpet av de siste årene

Målet er å gi utviklere stuktur ved hjelp av et sett med byggeklosser

---

class: middle, center

# Et sett med problemstillinger og misforståelser

---

class: middle, center

# Hvem har ansvar for hva?

---

# Hvem har ansvar for hva?

Fort blir mye som skjer overalt i en stor JavaScript-applikasjon

Det blir vanskelig å få oversikt og det er lett å innføre "bugs"

Backbone sine byggeklosser er laget for å hjelpe til:

- Modeller
- Collections
- Views
- Router

Hver byggekloss har sine spesifikke ansvarsområder

---

# Model

---

# Collection

---

# View

template

---

# Router

---

# Events

---

# Hvem har ansvar for hva?

Kommunikasjon

![](backbone_structure.png)

---

class: middle, center

# For mye skjer i `initialize`

---

# For mye skjer i `initialize`

```javascript
var UserView = Backbone.View.extend({

    initialize: function() {

        // lager en modell
        var user = new User();

        var self = this;

        // henter data
        user.fetch({

            success: function() {
                // rendrer view når data er mottatt
                self.render();
            }

        });

    }

});
```

<!-- 
Notes:

- Vanskelig å mock bort user
- Starter ajaxkallet når man new'er opp objektet, så hver gang noen sier new UserView vil det automagisk gå ett ajax request
- Kaller render fra initialize via callbacket til success

-->

---

# For mye skjer i `initialize`

Viewet skal helst ikke hente sin egen data, det skal få data

Viewet skal respondere på data-endringer

```javascript
var UserView = Backbone.View.extend({

    initialize: function(options) {
        this.user = options.user;
        this.user.on('change', this.render, this);
    }

});

var user = new User();
var userView = new UserView({ user: user });
user.fetch();
```

---

class: middle, center

# For mye logikk i viewene

---

# For mye logikk i viewene

Her er et eksempel på en model `Transaction` og en collection `Transactions`

Vi skal lage et view som presenterer en liste med `Transactions`

```javascript
var Transaction = Backbone.Model.extend({
    defaults: {
        sum: undefined,
        from: undefined,
        to: undefined,
        createdAt: undefined,
        type: undefined
    }
});

var Transactions = Backbone.Collection.extend({
    model: Transaction
});
```

---

# For mye logikk i viewene

```javascript
var TransactionsView = Backbone.View.extend({
    events: {
        'click .sortByDate': 'sortByDateAndType'
    },
    initialize: function(options) {
        this.transactions = options.transaction;
    },
    sortByDateAndType: function(e) {
        e.preventDefault();

        var type = this.$('.transaction-type:selected').val();
        this.transactions.sortBy(function(transaction) {
            var timestamp = Date.parse(transaction.get('createdAt')) * 1000;
            if (type === 'something') {
                timestamp += "A";
            } else if (type === 'somethingElse') {
                timestamp += "B";
            } else if (type === 'someOtherThing') {
                timestamp += "C";
            }
            return timestamp;
        });
    }
});
```

---

# For mye logikk i viewene

Flytt logikk til `model` og `collection`:

```javascript
var TransactionsView = Backbone.View.extend({

    events: {
        'click .sortByDate': 'sortByDateAndType'
    },

    initialize: function(options) {
        this.transactions = options.transaction;
    },

    sortByDateAndType: function(e) {
        e.preventDefault();

        var type = this.$('.transaction-type:selected').val();
        this.transactions.sortByDateAndType(type);
    }

});
```

---

class: middle, center

Kim tar over

# View'ene mine blir alt for store

---

# View'ene mine blir alt for store

SCREENSHOT

Når man begynner å lage et view så er de ofte små og løser enkle problemer

Med tiden så kan hvert enkelt view løse for mange problemer

De blir store og klumpete

Vanskelig å få oversikt

Vanskelig å teste

---

# View'ene mine blir alt for store

For å gjøre det enklere å håndtere store views kan man bruke sub-views

Sub-views har som hensikt å løse ett enkelt problem for et overordnet view

De skal kunne flyttes rundt uten konsekvenser

De skal kunne gjenbrukes på tvers av parent views

---

# View'ene mine blir alt for store

```javascript
var PersonView = Backbone.View.extend({});

var AddressView = Backbone.View.extend({});

var PersonalInformationView = Backbone.View.extend({

    initialize: function(options) {
        this.addressView = new AddressView({ address: options.address });
        this.personView = new PersonView({ person: options.person });
    },

    render: function() {
        this.renderTemplate();

        this.personView.setElement(this.$('#person'));
        this.personView.render();

        this.addressView.setElement(this.$('#address'));
        this.addressView.render();

        return this;
    }
});
```

---

class: middle, center

# Arv

---

# Arv

`BaseView` osv

`Mustache.to_html(..., ...)` overalt. Kan legge i BaseView eller noe lignende.

---

# Oppdatere markup er ett mareritt

kjipt å endre en header som er vanlig å ha på de fleste sider

For eksempel så vil man bruke `h2` i stedet for `h1`

Kan være overkill å lage et subview for en liten header

---

# Oppdatere markup er ett mareritt

Mulig løsning: Partials!

Partials er deler av templates som kan dyttes inn hvor de trengs.

```html
<h1>{{title}}</h1>
<h2 class="sub-title">{{subTitle}}</h2>
```

```html
{{>header}}

<p>{{person.firstname}} {{person.lastname}}</p>
```

```html
{{>header}}

<p>{{address.postal}}</p>
<p>{{address.cordinates}}<p>
```

---

class: middle, center

# Koden min skal dele data

# Mulig nytt fokus: Det er viktig at det bare finnes én

---

# Koden min skal dele data

!! DENNE ER VANSKELIG Å FORSTÅ

- Hva er en singleton?

I mange tilfeller så ønsker man å dele data mellom flere objekter i applikasjonen

Se for deg at man for eksempel har et collection som henter ett sett med regler som styrer hva som er mulig å gjøre i applikasjonen, her er det naturlig å velge å bruke en singleton

---

# Koden min skal dele data

Gjør det slik at en singleton ikke kan new'es opp på noen annen måte

- Dette gjør at man ikke vil få situasjoner der man ikke vet om man påvirker andre når man endrer den

Bruk konstruktør injection når man bruker singletons, slik at de blir enkle å mocke bort under testing

Begrens antall singletons, se etter andre mekanismer, som for eksempel minne-cash, session-storage, local-storage

```javascript
define(['Backbone', 'modules/rule/rule'], function(Backbone, Rule) {
    var Rules = Backbone.Collection.extend({
        model: Rule
    });

    return new Rules();
});
```

Singletons kan være positivt, men det er noen problemer:

- Blir for store
- Vet for mye
- Brukt for direkte
- De blir vanskelig å teste
- Inneholder masse state

---

class: middle, center

# Backbone-plugins = jQuery-plugins

---

# Backbone-plugins = jQuery-plugins

Shitty kvalitet på det meste

Plugins skal i teorien vœre komponenter som løser et problem som et rammeverk ikke ønsker å ta stilling til

Mange plugins tar over kode som ligger på `Backbone`

Eksempel fra `Backbone.localStorage`:

```javascript
// Override 'Backbone.sync' to default to localSync,
// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'

Backbone.sync = function(method, model, options) {
    return Backbone.getSyncMethod(model).apply(this, [method, model, options]);
};
```

---

# Backbone-plugins = jQuery-plugins

## Tips

- Sjekk kodekvaliteten på pluginen du ønsker å dra inn
- Ikke gjør applikasjonen din for avhengig, utvikling på pluginen kan plutselig slutte
- Plugins kan vœre kult og gjøre mye magi, men husk at magien blir fort ødelagt om man ønsker å gjøre små endringer

Følg Hollywood-prinsippet:

> Don't call me, I'll call you

---

# Trenger du egentlig denne plugin-en?

Lett å dra inn — potensielt masse kompleksitet

Det kan være godt dokumenterte plugins med masse oppdateringer og followers

Man bør da tenke, hvilke problem ønsker jeg å løse og løser pluginen akkurat det problemet og ikke det pluss alt annet?

Store avhengigheter er mer kompleksitet som alle må forstå.

For eksempel:

- [Backbone-relational.js](http://backbonerelational.org/) er større enn Backbone selv

---

# Trenger du egentlig denne plugin-en?

Enkelt å la en modell inneholde en collection:

    .javascript
    var Inbox = Backbone.Model.extend({

      initialize: function() {
        this.messages = new Messages();
      },

      parse: function(resp) {
        this.messages.update(_.clone(resp.messages), { parse: true });
        delete resp.messages;
        return resp;
      },

      toJSON: function() {
        var json = _.clone(this.attributes);
        json.messages = this.messages.toJSON();
        return json;
      }

    });


---

class: middle, center

# Backbone brukes der det ikke trengs

---

# Backbone brukes der det ikke trengs

!! Komponenter

Komponenter som vi har valgt å kalle dem er et forsøk på å bidra til å gjøre plugins mer håndterbare

De skal vœre små

Løse enkle problemer

Hindre duplisering av kode

Backbone modeller og collections brukes der man trenger å hente data

Views brukes til å vise dataen

Alle komponentene rundt trenger ikke vœre knyttet til rammeverket

Komponenter skal vœre lette, løse små problemer og ha få avhengigheter

Vi vil gå igjennom noen eksempler på komponenter

---

class: middle, center

# Filer ligger overalt

---

# Filer ligger overalt

Kan virke banalt, men det er utrolig viktig

Mappestruktur. Ikke lag egne views, models og collections mapper. Samle moduler
i egen mappe. Dette gjør det faktisk enklere å få rask oversikt over hva app-en
gjør (se på mappenavnene i modules-mappa)

- component
- module
- external

Eller?

- model
- collections
- views
- router
- external

Tilhørlighet

---

# Filer ligger overalt

```sh
$ tree
.
├── app.js
├── components
│   ├── subViewHandler.js
│   └── validation.js
├── index.html
├── libs
│   ├── backbone-0.9.10.js
│   ├── jquery-1.9.1.js
│   └── underscore-1.4.4.js
└── modules
    └── payments
        ├── payment.js
        ├── payment.mustache
        ├── paymentView.js
        └── payments.js

4 directories, 11 files
```

---

# Filer ligger overalt

Require.js-eksempel. Trenger ikke lengre "full path".

---

class: middle, center

# Huskeliste

---

# Huskeliste

Testbarhet ≈ struktur

Ny i kodebasen

Når man er ny i en kodebase, selv med god kjennskap til rammeverkene, møter man nye måter å bruke rammeverkene på. 

En huskeregel når man koder kan vœre å ikke overkomplisere enkle problemer, eller løse fremtidige problemer

Følg rammeverket man har valgt og ikke kjemp mot det

En annen viktig ting kan vœre å hele tiden tenke på at det kommer en etter deg


	.javascript
	var Transaction = Backbone.Model.extend({});
	
mot
	
	.javascript
	var Transaction = Backbone.Model.extend({
		defaults: {
 			sum: undefined,
            from: undefined,
            to: undefined,
            createdAt: undefined,
            type: undefined
		}	
	});
	

<!--
Ikke gjør for masse magi. Gjør det enkelt og forståelig. Ha en overordnet
"filosofi". Her passer kanskje MVP og sånt.
 -->

---

class: middle, center, black

# Spørsmål?

# Uenig?

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
